const EventEmitter = require('events')
const sublevel = require('subleveldown')
const LevelUtil = require('./util-level')
const {debug, veryDebug} = require('./util')

// typedefs
// =

/**
 * @typedef {Object} InternalEntryValue
 * @prop {string} fileUrl
 * @prop {any} value
 *
 * @typedef {Object} InternalEntry
 * @prop {any} key
 * @prop {InternalEntryValue[]} value
 *
 * @typedef {Object} Entry
 * @prop {any} key
 * @prop {any} value
 */

// exported api
// =

class View extends EventEmitter {
  constructor (db, name, definition) {
    super()
    veryDebug('View', name, definition)
    this.db = db
    this.name = name
    this.filePattern = definition.path
    this.map = definition.map
    this.reduce = definition.reduce

    // construct db objects
    const levelOpts = {keyEncoding: 'json', valueEncoding: 'json'}
    this.level = sublevel(db.level, name, levelOpts)
    this.archiveVersionLevel = sublevel(this.level, 'av', levelOpts)
    this.entriesByFileLevel = sublevel(this.level, 'ebf', levelOpts)
    this.entriesLevel = sublevel(this.level, 'e', levelOpts)
    if (this.reduce) {
      this.reducesLevel = sublevel(this.level, 'r', levelOpts)
    }
  }

  /**
   * @param {any} key
   * @returns {Promise<Entry>}
   */
  async get (key) {
    if (this.reducesLevel) {
      let v = await LevelUtil.get(this.reducesLevel, key)
      if (!v) return v
      return {key, value: v}
    } else {
      let v = await LevelUtil.get(this.entriesLevel, key)
      if (!v) return v
      return {key, value: v.map(({value}) => value)}
    }
  }

  /**
   * @param {Object} opts
   * @returns {Promise<Entry[]>}
   */
  async list (opts) {
    if (this.reducesLevel) {
      // simple case- list the items directly
      return LevelUtil.list(this.reducesLevel, opts)
    }

    // mapped entries can have multiple values per key
    // run the list() query and then flatten the results into a single array
    var entries = []
    var items = await LevelUtil.list(this.entriesLevel, opts)
    for (let item of items) {
      for (let v of item.value) {
        entries.push({key: item.key, value: v.value})
      }
    }
    return entries
  }

  /**
   * @param {string} fileUrl
   * @param {Entry[]} entries
   */
  async addEntries (fileUrl, entries) {
    veryDebug('addEntries()', this.name, fileUrl, entries)

    // store in the db:
    // - (data) the values are added to the array of values at the given key
    // - (meta) the keys related to this file are stored as an array
    var ps = []
    var keys = []
    for (let entry of entries) {
      keys.push(entry.key)
      ps.push(LevelUtil.push(this.entriesLevel, entry.key, {fileUrl, value: entry.value}))
    }
    ps.push(LevelUtil.put(this.entriesByFileLevel, fileUrl, keys))
    await Promise.all(ps)
  }

  /**
   *
   * @param {string} key
   * @returns {Promise<InternalEntry>}
   */
  async getEntries (key) {
    return LevelUtil.get(this.entriesLevel, key)
  }

  /**
   * @param {string} fileUrl
   * @returns {Promise<any[]>}
   */
  async getEntryKeysByFile (fileUrl) {
    return LevelUtil.get(this.entriesByFileLevel, fileUrl)
  }

  /**
   * @param {string} fileUrl
   * @returns {Promise<void>}
   */
  async clearEntriesByFile (fileUrl) {
    veryDebug('clearEntriesByFile()', this.name, fileUrl)

    // fetch keys of entries generated by the file
    var keys = await LevelUtil.get(this.entriesByFileLevel, fileUrl)
    if (!keys || !keys.length) return

    for (let key of keys) {
      // get the entries for the key
      var entries = await LevelUtil.get(this.entriesLevel, key)

      // remove any entry generated by the file
      entries = entries.filter(entry => entry.fileUrl !== fileUrl)
      if (!entries.length) {
        await LevelUtil.del(this.entriesLevel, key)
      } else {
        await LevelUtil.put(this.entriesLevel, key, entries)
      }
    }

    // remove the pointer as all related data has been removed
    await LevelUtil.del(this.entriesByFileLevel, fileUrl)
  }

  /**
   * @param {any} key
   * @param {any} acc
   * @returns {Promise<void>}
   */
  async putReducedValue (key, acc) {
    veryDebug('putReducedValue()', this.name, key, acc)
    if (typeof acc === 'undefined') {
      await LevelUtil.del(this.reducesLevel, key)
    } else {
      await LevelUtil.put(this.reducesLevel, key, acc)
    }
  }

  /**
   * @returns {Promise<void>}
   */
  async clearData () {
    veryDebug('clearData()', this.name)
    await LevelUtil.clear(this.level)
  }
}

module.exports = View
